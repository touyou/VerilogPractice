 ステップとして、12ステップにわかれている。それをクロックにあわせて変えるのでこれをどうにかして組み合わせに落とし込む＆仕様にあわせる作業が必要

- ①②aとbを読み込む。これはリセット信号で計算し直すため。
- ③aとbをs,e,mに分ける。コードではこの時3bit分仮数を0で底上げし、eを符号付き整数になおしている。
- ④special_casesでまずNaNやinf、0の処理を行っている。この時$signed()を使っているが、結構ややこしいから符号付きに直さないほうがいいかも。あと非正規化数のeを-126に、それ以外の数の仮数の最上位を1にしている
- ⑤eの大きいほうにあわせて片方の数をシフトしている。シフトするとき仮数の最下位bitはその一個上とORをとっている（ここらへんはulpとかの演算に対応？）（というか切り捨てられた1があるかどうかを格納か）
- ⑥一個目のadd_0では符号をみて同じなら仮数の和をsumレジスタに、違うなら差をsumレジスタに格納する。また結果のsは同じならそのまま、違うなら仮数の大きい方を格納する
- ⑦add_1ではsumの最上位bitをみて仮の結果の仮数とGuard,RoundBit,Stickyを計算している。sumの最上位bitが1の時はsum[27:4]が仮数で
    - Guard = sum[3]
    - RoundBit = sum[2]
    - Sticky = sum[1] | sum[0]
  - となり結果のeは1上がっている。そうでないときはsum[26:3]が仮数で
    - Guard = sum[2]
    - RoundBit = sum[1]
    - Sticky = sum[0]
  - となる。
- ⑧次は正規化で、仮数のMSBが0かつ指数が-125以上の間、仮数を左シフトしていく。仮数の最下位bitがGuardでGuardにはRoundBitを、RoundBitはシフト後は0になる。
- ⑨上の処理が終わったら、指数が-126未満になった時指数を足して右シフトしていく。Guardを仮数の最下位bit、RoundBitをGuard、stickyをstickyとRoundBitのORに設定する。
- ⑩上が終わったら丸めに入る。Guardが1かつRoundBitとStickyと仮数の最下位bitのいずれかが1なら仮数に1を足し、仮数の全bitが1になったら指数にも1を足す
（どの丸めに対応してるか誰か補足してくださいいい）
- ⑪丸めがおわったら結果にassignする。この時指数が-126、仮数のMSBが0なら指数部を0に、指数が128以上ならオーバーフローということで無限を返している
- Guardが1/2ulp、Rが1/4ulp、Stickyはそれより下のところに1があるかないか。
- つまりGuard=1、R=0、Sticky=0の時1/2ulpに等しい
- その他の場合はGuard=1なら1/2ulpより上、Guard=0なら1/2ulpより下
- シフトの時はStickyに気をつけながらやる
- ということは、最上位が1の時はcarryがある→上を捨てないように上を取る
